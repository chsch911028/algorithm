# 두 문자열 사이의 거리

<br>

### 문제

----------

두 문자열 A, B 가 주어질 때, 두 문자열 사이의 거리를 구하려 한다. 여기서 거리는 다음과 같이 정의된다. 문자열 A가 주어질 때, 여기서 하나의 연산은 하나의 알파벳을 삽입 또는 삭제하는 것을 의미한다. 문자열 A와 B 사이의 거리란, A에서 시작하여 B를 만들기 위한 최소 연산의 횟수로 정의된다. 예를 들어, 문자열 A가 “abcabcd”이고, 문자열 B가 “abccabc” 라면, 문자열 A와 B 사이의 거리는 2가 된다. 왜냐하면 문자열 A의 세 번째에 ‘c’를 삽입하고, 가장 마지막에 있는 ‘d’를 삭제하면 문자열 B를 얻기 때문이다. 두 문자열이 주어질 때, 두 문자열 사이의 거리를 출력하는 프로그램을 작성하시오.

### 입력

----------

첫 번째 줄과 두 번째 줄에 문자열이 주어지며, 이 문자열의 길이는 1000을 넘지 않는다. 주어진 문자열은 대소문자가 섞여있다.

### 출력

----------

두 문자열 사이의 거리를 출력한다. (대문자 'A'와 소문자 'a'는 다른 문자로 취급한다.)

### 예제 입력

```
abcabcd
abccabc
```

### 예제 출력

```
2
```

### 코드

```java
import java.util.Scanner;
public class Main{
    public static void main(String[] args){

      // Please Enter Your Code Here
      Scanner sc = new Scanner(System.in);
      String a_str = sc.nextLine();
      String b_str = sc.nextLine();
      
      String a_arr[] = a_str.split("");
      String b_arr[] = b_str.split("");
      
      
      //T[i][j]: 문자열 A(0~i번째)와 문자열 B(0~j번째)가 같아지기 위위쪽
      //         최소 연산의 횟수
      // **POINT: i,j를 한칸씩 크게 잡는다
      //        => 왜? 두문자열 한개도 없는 경우를 생각해야
      //        => 대각선, 왼쪽, 위쪽의 연산횟수를 활용할 수 있다.
      //
      // * 대각선 T 의미: (A의 i-1번째 문자열)과 (B의 j-1번째 문자열)이 같고, 
      //                 T[i-1][j-1]에 그 연산의 횟수가 저장되 있음
      // * 왼쪽 T 의미: (A의 i번째 문자열)과 (B의 j-1번째 문자열)이 같고, 
      //               T[i][j-1]에 그 연산의 횟수가 저장되어 있음
      // * 위쪽 T 의미: (A의 i-1번째 문자열)과 (B의 j번째 문자열)이 같고, 
      //               T[i-1][j]에 그 연산의 횟수가 저장되어 있음
      //
      // 왜? 3가지 경우를 통해서 T[i][j]가 결정되는가?
      // 1) A[i] 와 B[j] 문자열이 같은 경우(=최소 0개 연산 사용됨)
      //    -> (1) 대각선 + 0: 문자열 A와 문자열 B가 한단계 이전 문자열이 같음,
      //                       현재 서로 같은 문자를 같기 때문에 연산 필요 없음(0)
      //    -> (2) 왼쪽 + 1: 문자열 A가 문자열 B보다 한개 많기 때문에 1개 추가or삭제
      //    -> (3) 위쪽 + 1: 문자열 B가 문자열 A보다 한개 많기 때문에 1개 추가or삭제
      //
      // 2) A[i] 와 B[j] 문자열이 다른 경우(=최소 1개 연산 필요)
      //
      //    -> (1) 대각선 + 0: 문자열 A와 문자열 B가 한단계 이전 문자열이 같음,
      //                       현재 서로 다른 문자를 같기떄문에 추가/삭제 or 추가/추가 or 삭제/삭제 
      //                       어느 옵션이던 2개의 연산을 해야함
      //    -> (2) 왼쪽 + 1: 문자열 A가 문자열 B보다 한개 많기 때문에 1개 추가or삭제
      //    -> (3) 위쪽 + 1: 문자열 B가 문자열 A보다 한개 많기 때문에 1개 추가or삭제
            
      int T[][] = new int[a_arr.length+1][b_arr.length+1];
          
      for(int i=0; i<=a_arr.length; i++){//row
        
        for(int j=0; j<=b_arr.length; j++){//col
          
          //T(0,0) 세팅
          if(i == 0 && j == 0){ T[0][0] = 0; continue; }
          
          //맨 윗줄 세팅
          if(i == 0){ 
            //왼쪽 + 1
            T[i][j] = T[i][j-1] + 1; continue;
          }
          
          //맨 왼쪽줄 세팅
          if(j == 0){ 
            // 위쪽 + 1
            T[i][j] = T[i-1][j] + 1; continue;
          }
          
          //나머지 T는 왼쪽,위쪽,왼쪽대각선 값을 기준으로 판단됨
          String a = a_arr[i-1];
          String b = b_arr[j-1];
          if(a.equals(b)){ // 같은 문자라면
            //3개의 선택중 가장 작은 연산을 선택
            T[i][j] = T[i-1][j-1] + 0;
            if(T[i-1][j]+1 < T[i][j]){ T[i][j] = T[i-1][j]+1;}
            if(T[i][j-1]+1 < T[i][j]){ T[i][j] = T[i][j-1]+1;}
          }else{// 다른 문자라면
            //3개의 선택중 가장 작은 연산을 선택
            T[i][j] = T[i-1][j-1] + 2;
            if(T[i-1][j]+1 < T[i][j]){ T[i][j] = T[i-1][j]+1;}
            if(T[i][j-1]+1 < T[i][j]){ T[i][j] = T[i][j-1]+1;}
          }
          
        }
      }
      
      System.out.println(T[a_arr.length][b_arr.length]);
      
    }
}
```